import os
import json
import uuid
import base64
import tempfile
import logging
import typing
from io import BytesIO
from functools import wraps

from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
from werkzeug.utils import secure_filename
from werkzeug.exceptions import RequestEntityTooLarge
from PIL import Image as PIL_Image
from google import genai
from google.genai.types import (
    Image,
    ProductImage,
    RecontextImageConfig,
    RecontextImageSource,
)
from google.oauth2 import service_account
from dotenv import load_dotenv
import gunicorn

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('app.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Initialize Flask app
app = Flask(__name__)

# Configuration
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max file size
app.config['UPLOAD_FOLDER'] = tempfile.gettempdir()

# Enable CORS
CORS(app, 
     origins=['*'], 
     methods=['GET', 'POST', 'OPTIONS'],
     allow_headers=['Content-Type', 'Authorization'])

# Constants
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}
ALLOWED_MIME_TYPES = {'image/jpeg', 'image/jpg', 'image/png', 'image/gif'}
VALID_CATEGORIES = ['upper_body', 'lower_body', 'dresses']

# Google AI Configuration
PROJECT_ID = os.getenv("PROJECT_ID", "poetic-chariot-471517-p8")
LOCATION = os.getenv("LOCATION", "us-central1")

# Initialize Google AI client
client = None
try:
    if os.getenv("GOOGLE_APPLICATION_CREDENTIALS_JSON"):
        service_account_info = json.loads(os.getenv("GOOGLE_APPLICATION_CREDENTIALS_JSON"))
        credentials = service_account.Credentials.from_service_account_info(
            service_account_info,
            scopes=["https://www.googleapis.com/auth/cloud-platform"]
        )
        client = genai.Client(
            vertexai=True, 
            project=PROJECT_ID, 
            location=LOCATION, 
            credentials=credentials
        )
        logger.info("✅ Google AI client initialized successfully")
    else:
        logger.error("❌ GOOGLE_APPLICATION_CREDENTIALS_JSON not found in environment")
except Exception as e:
    logger.error(f"❌ Failed to initialize Google AI client: {e}")
    client = None

def allowed_file(filename):
    """Check if uploaded file has allowed extension"""
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def validate_image_file(file):
    """Validate uploaded image file"""
    if not file or not file.filename:
        return False, "No file provided"
    
    if not allowed_file(file.filename):
        return False, f"Invalid file format. Allowed: {', '.join(ALLOWED_EXTENSIONS)}"
    
    # Check file size by seeking to end
    file.seek(0, 2)
    file_size = file.tell()
    file.seek(0)
    
    if file_size > app.config['MAX_CONTENT_LENGTH']:
        return False, "File too large. Maximum size is 16MB"
    
    if file_size == 0:
        return False, "Empty file provided"
    
    return True, "Valid file"

def save_uploaded_file(file):
    """Save uploaded file to temporary location and return path"""
    try:
        filename = secure_filename(f"{uuid.uuid4()}_{file.filename}")
        temp_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        file.save(temp_path)
        logger.info(f"File saved to: {temp_path}")
        return temp_path
    except Exception as e:
        logger.error(f"Error saving file: {e}")
        return None

def pil_image_to_base64(pil_image):
    """Convert PIL Image to base64 string"""
    try:
        buffer = BytesIO()
        if pil_image.mode != "RGB":
            pil_image = pil_image.convert("RGB")
        pil_image.save(buffer, format='PNG')
        encoded_string = base64.b64encode(buffer.getvalue()).decode('utf-8')
        return encoded_string
    except Exception as e:
        logger.error(f"Error converting image to base64: {e}")
        raise

def cleanup_files(file_paths):
    """Clean up temporary files"""
    for file_path in file_paths:
        try:
            if file_path and os.path.exists(file_path):
                os.remove(file_path)
                logger.info(f"Cleaned up file: {file_path}")
        except Exception as e:
            logger.warning(f"Could not delete temp file {file_path}: {e}")

def require_ai_client(f):
    """Decorator to check if AI client is available"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not client:
            return jsonify({
                'success': False,
                'error': 'Service unavailable - Google AI client not initialized',
                'message': 'The AI service is currently unavailable. Please try again later.'
            }), 503
        return f(*args, **kwargs)
    return decorated_function

# Error handlers
@app.errorhandler(RequestEntityTooLarge)
def handle_file_too_large(e):
    logger.warning("File upload too large")
    return jsonify({
        'success': False,
        'error': 'File too large',
        'message': 'Maximum file size is 16MB'
    }), 413

@app.errorhandler(404)
def handle_not_found(e):
    return jsonify({
        'success': False,
        'error': 'Endpoint not found',
        'message': 'The requested endpoint does not exist'
    }), 404

@app.errorhandler(500)
def handle_internal_error(e):
    logger.error(f"Internal server error: {e}")
    return jsonify({
        'success': False,
        'error': 'Internal server error',
        'message': 'An unexpected error occurred. Please try again later.'
    }), 500

@app.errorhandler(405)
def handle_method_not_allowed(e):
    return jsonify({
        'success': False,
        'error': 'Method not allowed',
        'message': 'The requested method is not allowed for this endpoint'
    }), 405

# Routes
@app.route('/', methods=['GET'])
def home():
    """API documentation endpoint"""
    return jsonify({
        'message': 'Virtual Try-On API - Google Gemini Edition',
        'version': '1.0.0',
        'status': 'healthy' if client else 'unhealthy',
        'endpoints': {
            '/': {
                'method': 'GET',
                'description': 'API documentation and status'
            },
            '/health': {
                'method': 'GET',
                'description': 'Check API health status'
            },
            '/try-on': {
                'method': 'POST',
                'description': 'Upload person and clothing images for virtual try-on',
                'parameters': {
                    'person_image': 'Image file of person (required)',
                    'clothing_image': 'Image file of clothing (required)',
                    'garment_description': 'Description of the garment (optional, default: "stylish clothing")',
                    'category': 'Category: upper_body, lower_body, or dresses (optional, default: "upper_body")'
                },
                'accepted_formats': list(ALLOWED_EXTENSIONS),
                'max_file_size': '16MB'
            }
        },
        'model': 'virtual-try-on-preview-08-04'
    })

@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    status = 'healthy' if client else 'unhealthy'
    message = 'API is running' if client else 'Google AI client not initialized'
    
    return jsonify({
        'status': status,
        'message': message,
        'model': 'virtual-try-on-preview-08-04',
        'timestamp': str(int(__import__('time').time())),
        'version': '1.0.0'
    }), 200 if client else 503

@app.route('/try-on', methods=['POST'])
@require_ai_client
def virtual_try_on():
    """Main virtual try-on endpoint"""
    person_path = None
    clothing_path = None
    
    try:
        # Validate request
        if 'person_image' not in request.files or 'clothing_image' not in request.files:
            return jsonify({
                'success': False,
                'error': 'Missing required files',
                'message': 'Both person_image and clothing_image are required'
            }), 400
        
        person_image = request.files['person_image']
        clothing_image = request.files['clothing_image']
        garment_description = request.form.get('garment_description', 'stylish clothing')
        category = request.form.get('category', 'upper_body')
        
        # Validate category
        if category not in VALID_CATEGORIES:
            return jsonify({
                'success': False,
                'error': 'Invalid category',
                'message': f'Category must be one of: {", ".join(VALID_CATEGORIES)}'
            }), 400
        
        # Validate person image
        is_valid, message = validate_image_file(person_image)
        if not is_valid:
            return jsonify({
                'success': False,
                'error': 'Invalid person image',
                'message': message
            }), 400
        
        # Validate clothing image
        is_valid, message = validate_image_file(clothing_image)
        if not is_valid:
            return jsonify({
                'success': False,
                'error': 'Invalid clothing image',
                'message': message
            }), 400
        
        # Save files
        person_path = save_uploaded_file(person_image)
        clothing_path = save_uploaded_file(clothing_image)
        
        if not person_path or not clothing_path:
            return jsonify({
                'success': False,
                'error': 'File processing error',
                'message': 'Failed to process uploaded files'
            }), 500
        
        logger.info(f"Processing try-on with category: {category}, description: {garment_description}")
        
        # Call Google Gemini Virtual Try-On API
        response = client.models.recontext_image(
            model="virtual-try-on-preview-08-04",
            source=RecontextImageSource(
                person_image=Image.from_file(location=person_path),
                product_images=[ProductImage(product_image=Image.from_file(location=clothing_path))],
            ),
            config=RecontextImageConfig(
                base_steps=32,
                number_of_images=1,
                person_generation="allow_all",
            ),
        )
        
        logger.info("Google AI API call successful!")
        
        # Process the generated image
        if not response.generated_images:
            return jsonify({
                'success': False,
                'error': 'No image generated',
                'message': 'The AI model did not generate any images. Please try again.'
            }), 500
        
        result_image = typing.cast(PIL_Image.Image, response.generated_images[0].image._pil_image)
        output_base64 = pil_image_to_base64(result_image)
        
        # Clean up temporary files
        cleanup_files([person_path, clothing_path])
        
        return jsonify({
            'success': True,
            'message': 'Virtual try-on completed successfully',
            'results': {
                'try_on_image': f"data:image/png;base64,{output_base64}",
                'masked_image': None  # Gemini model doesn't provide masked image
            },
            'parameters': {
                'garment_description': garment_description,
                'category': category,
                'model': 'virtual-try-on-preview-08-04'
            }
        })
        
    except Exception as e:
        # Clean up files in case of error
        cleanup_files([person_path, clothing_path])
        
        logger.error(f"Error during try-on: {str(e)}")
        return jsonify({
            'success': False,
            'error': 'Virtual try-on failed',
            'message': f'An error occurred during processing: {str(e)}'
        }), 500

@app.route('/favicon.ico')
def favicon():
    """Favicon endpoint to prevent 404 errors"""
    return '', 204

# Production WSGI application
if __name__ == '__main__':
    port = int(os.getenv('PORT', 5000))
    debug = os.getenv('FLASK_ENV') == 'development'
    
    if not debug:
        logger.info("Starting production server...")
    
    app.run(
        host='0.0.0.0',
        port=port,
        debug=debug,
        threaded=True
    )